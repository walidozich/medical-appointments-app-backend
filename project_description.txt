Below is the **formal translation of your mobile-app feature list into a complete backend project specification**, fully aligned with the 12-step project-planning process you validated.
This gives you a **clean and professional requirements baseline** before architecture, FastAPI design, or data modeling.

If this matches what you want, I will then proceed to:

* System architecture for FastAPI
* Data model (ERD)
* API specification
* Workflow diagrams
* Development plan

---

# 1. Functional Requirements

(Organized by modules as a backend engineer would)

## 1.1 Authentication & Access Control

* The system shall allow users to create an account using email/password.
* The system shall support social authentication (Google, Facebook).
* The system shall provide secure login and logout.
* The system shall provide password recovery via email.
* The system shall enforce per-user access control (patients vs. doctors vs. admins).
* The system shall issue short-lived access tokens and long-lived refresh tokens.

## 1.2 Doctor Management

* The system shall allow users to browse doctors by specialty.
* The system shall provide a detailed profile for each doctor (bio, specialty, availability, ratings).
* The system shall support searching doctors by name, specialty, or location.
* The system shall allow users to save favorite doctors.
* The system shall store ratings and reviews.

## 1.3 Appointment System

* The system shall allow patients to book appointments with doctors.
* The system shall verify doctor availability before confirming appointments.
* The system shall allow patients to reschedule or cancel appointments.
* The system shall provide appointment history (past, upcoming, cancelled).
* The system shall provide a calendar-friendly view for appointment times.
* The system shall notify doctors and patients of appointment changes.

## 1.4 Communication (Chat)

* The system shall support patient–doctor messaging.
* The system shall store chat history securely.
* The system shall deliver real-time chat notifications.
* The system shall support read receipts or message status (optional).

## 1.5 Payment Module

* The system shall allow users to pay for appointments via multiple payment methods.
* The system shall integrate with a payment gateway.
* The system shall record all payment transactions.
* The system shall generate digital receipts (PDF or structured data).
* The system shall handle refunds (optional, depending on requirements).

## 1.6 User Profile & Settings

* The system shall allow users to edit personal information.
* The system shall allow users to configure preferences (language, notifications, dark mode).
* The system shall provide a help center (FAQ, support requests).
* The system shall expose policies (privacy, terms).

## 1.7 Advanced App Features (Backend Support)

* The backend shall support multiple languages (EN/FR).
* The backend shall expose theme preference (light/dark).
* The backend shall support offline caching by providing sync endpoints.
* The backend shall support device information for analytics or debugging.

---

# 2. Non-Functional Requirements

## Performance

* API response time < 200 ms for 95% of requests.
* Real-time chat latency < 300 ms.

## Scalability

* The system shall scale horizontally (Kubernetes, containers).
* Messaging and notifications must handle 10k concurrent users.

## Security

* JWT-based authentication (access + refresh tokens).
* Encryption of sensitive data at rest (database).
* End-to-end TLS encryption in transit.
* Secure OAuth2 social login.
* Audit logging for key operations.
* Role-based access control (RBAC).

## Reliability / Availability

* Uptime target: 99.5%
* Zero-downtime deployments (blue/green or rolling).
* Automatic retry logic for failed notifications and payments.

## Maintainability

* The backend shall follow clean architecture principles.
* Code shall follow PEP8 standards and include type hints.
* API documentation shall be autogenerated (OpenAPI).

## Observability

* Centralized logging
* Tracing (OpenTelemetry)
* Alerting for failures (authentication errors, failed payments, chat delivery issues)

---

# 3. User Stories & Acceptance Criteria

(Business-friendly format)

## Authentication

**Story:** As a user, I want to sign up and log in securely.
**Acceptance Criteria:**

* Valid credentials allow login and return tokens.
* Invalid credentials return standardized errors.
* Social login returns the same user object as email login.

## Browsing Doctors

**Story:** As a patient, I want to browse doctors by specialty so I can choose the right one.
**Acceptance Criteria:**

* I can filter by specialty, location, rating.
* I can view a doctor’s detailed page.
* I can mark a doctor as favorite.

## Appointment Booking

**Story:** As a patient, I want to book a doctor appointment at an available time.
**Acceptance Criteria:**

* Only free time slots are shown.
* Double-booking is prevented.
* Both doctor and patient receive notifications.

## Chat

**Story:** As a patient, I want to chat with my doctor.
**Acceptance Criteria:**

* Messages appear in less than 300 ms.
* Conversations remain saved even after logout.

## Payments

**Story:** As a patient, I want to pay securely.
**Acceptance Criteria:**

* The system must confirm payment success or failure.
* A receipt must be generated.
* Failed payments must not create appointments.

---

# 4. Scope Boundaries

### Included

* Admin dashboard (optional later)
* Patient mobile app backend
* Doctor-side functionalities (availability, messages)
* Payment integration
* Real-time chat
* Push notifications
* Multi-language
* Offline support (sync endpoints)

### Excluded (unless you add them)

* Video calls
* AI symptom checker
* Insurance management
* Hospital system integrations
* Medical record storage (EMR)
* Prescription generation

---

## Left to Do (implementation backlog)

* Social auth (Google, Facebook) and unify returned user object.
* Doctor discovery: search/browse by specialty/location/rating; favorites; reviews/ratings endpoints and aggregates.
* Doctor schedules: richer availability API with calendar-friendly slots.
* Chat: threads/messages + WebSocket real-time delivery and history.
* Payments: integrate payment gateway (e.g., Stripe) for appointment payments, webhooks, receipts.
* Notifications: push/email/SMS/in-app for bookings, changes, payments, chat.
* Admin dashboard APIs: manage specialties, reviews, users, reporting.
* Security/observability: rate limiting, audit logging, optional data-at-rest encryption for sensitive fields.
* Testing: pytest coverage for auth, RBAC, patients, doctors, appointments, medical records, billing.

## Progress Recap (done)

* Core auth: email/password, refresh tokens, logout with revocation, password reset.
* RBAC: roles table (Admin, Doctor, Patient, Staff); role guard dependency.
* Patients: profiles with identity/medical info; CRUD (self + admin).
* Doctors: profiles, specialties, availability; CRUD (self + admin); public listing.
* Appointments: booking with conflict checks vs availability; reschedule/cancel; statuses SCHEDULED/COMPLETED/CANCELLED.
* Medical Records: diagnoses/treatments/prescriptions; doctor/patient scoped access.
* Billing/Insurance: billing entries, policies, claims; admin + patient views.
* API envelope: standardized `{success, data, message}` responses; centralized exception handling.
* Migrations created for roles, patients, doctors, appointments, medical records, billing/insurance.

---





+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



Below is a complete design package for your backend.

I chose a **modular monolith** architecture implemented with FastAPI, structured into clear domains (auth, users/doctors, appointments, chat, payments, notifications). It is a single deployable unit now, but each module is isolated so you can later split into microservices if needed.

---

## 1. Architecture Style Recommendation

**Chosen style: Modular Monolith (Domain-oriented)**

**Why this is best for you now:**

* Your feature set is rich but tightly coupled around a single product (mobile app for doctor–patient interactions).
* You are one team (or a small team) and want to keep deployment simple.
* FastAPI is excellent for a modular monolith: routers per module, shared DB, shared infra.
* You can **evolve towards microservices** later by carving out modules (e.g., Payments, Chat) once traffic and team size grow.

**High-level modules (bounded contexts):**

* `auth` – authentication, token issuance, social login.
* `users` – patients, doctors, profiles, settings, favorites.
* `appointments` – scheduling, availability, calendar views.
* `chat` – real-time messaging (WebSockets), chat history.
* `payments` – payment intents, transactions, receipts.
* `notifications` – push/email/SMS, in-app notifications.
* `common` – shared infrastructure, logging, utilities.

---

## 2. Backend Components Diagram (Mermaid)

```mermaid
flowchart LR
    subgraph Client["Client Layer"]
        MobileApp["Mobile App (iOS/Android/WebView)"]
    end

    subgraph Backend["FastAPI Backend (Modular Monolith)"]
        APIGateway["API Layer (FastAPI Routers)"]

        subgraph AuthModule["Auth Module"]
            AuthService["Auth Service\n(JWT, OAuth2, Refresh Tokens)"]
        end

        subgraph UserModule["User & Doctor Module"]
            UserService["User Service\n(Patient/Doctor Profiles, Settings)"]
            DoctorService["Doctor Service\n(Specialties, Reviews, Favorites)"]
        end

        subgraph AppointmentModule["Appointment Module"]
            AppointmentService["Appointment Service\n(Booking, Reschedule, Cancel)"]
            AvailabilityService["Availability Service\n(Doctor Slots, Calendar)"]
        end

        subgraph ChatModule["Chat Module"]
            ChatAPI["Chat WebSocket Endpoint"]
            ChatService["Chat Service\n(Threads, Messages)"]
        end

        subgraph PaymentModule["Payment Module"]
            PaymentService["Payment Service\n(Payment Intents, Transactions)"]
            WebhookHandler["Payment Webhook Handler"]
        end

        subgraph NotificationModule["Notification Module"]
            NotificationService["Notification Service\n(Push, Email, In-App)"]
        end

        subgraph Infra["Infrastructure"]
            DB[(PostgreSQL)]
            Cache[(Redis)]
            Broker[("Message Broker\n(Redis / RabbitMQ)")]
            Storage["Object Storage\n(Receipts, Docs - optional)"]
        end
    end

    MobileApp -->|REST/JSON| APIGateway
    MobileApp -->|WebSocket| ChatAPI

    APIGateway --> AuthService
    APIGateway --> UserService
    APIGateway --> DoctorService
    APIGateway --> AppointmentService
    APIGateway --> PaymentService
    APIGateway --> NotificationService

    ChatAPI --> ChatService

    AuthService --> DB
    UserService --> DB
    DoctorService --> DB
    AppointmentService --> DB
    ChatService --> DB
    PaymentService --> DB
    NotificationService --> DB

    AppointmentService --> Cache
    ChatService --> Cache
    PaymentService --> Broker
    NotificationService --> Broker

    PaymentService --> WebhookHandler
    WebhookHandler --> DB
    WebhookHandler --> NotificationService
```

---

## 3. Data Model (ERD – Mermaid)

```mermaid
erDiagram
    USER {
        uuid id PK
        string email
        string password_hash
        string role  "PATIENT / DOCTOR / ADMIN"
        string locale  "en, fr"
        string theme_preference  "light/dark"
        boolean is_active
        timestamp created_at
        timestamp updated_at
    }

    PATIENT_PROFILE {
        uuid id PK
        uuid user_id FK
        string first_name
        string last_name
        date date_of_birth
        string phone
        string gender
        string address
        string city
        string country
    }

    DOCTOR_PROFILE {
        uuid id PK
        uuid user_id FK
        string first_name
        string last_name
        string phone
        string bio
        int years_experience
        string clinic_address
        string city
        string country
        float avg_rating
        int rating_count
    }

    SPECIALTY {
        int id PK
        string name
        string description
    }

    DOCTOR_SPECIALTY {
        uuid id PK
        uuid doctor_id FK
        int specialty_id FK
    }

    FAVORITE_DOCTOR {
        uuid id PK
        uuid patient_id FK
        uuid doctor_id FK
        timestamp created_at
    }

    REVIEW {
        uuid id PK
        uuid patient_id FK
        uuid doctor_id FK
        int rating  "1-5"
        string comment
        timestamp created_at
    }

    APPOINTMENT {
        uuid id PK
        uuid patient_id FK
        uuid doctor_id FK
        timestamp start_time
        timestamp end_time
        string status  "PENDING/CONFIRMED/CANCELLED/COMPLETED"
        string reason
        string cancellation_reason
        uuid payment_id FK
        timestamp created_at
        timestamp updated_at
    }

    DOCTOR_AVAILABILITY {
        uuid id PK
        uuid doctor_id FK
        string weekday  "Mon-Sun or ISO"
        time start_time
        time end_time
        boolean is_active
    }

    CHAT_THREAD {
        uuid id PK
        uuid patient_id FK
        uuid doctor_id FK
        timestamp created_at
        timestamp updated_at
    }

    CHAT_MESSAGE {
        uuid id PK
        uuid thread_id FK
        uuid sender_id FK
        string sender_role  "PATIENT/DOCTOR"
        text content
        timestamp sent_at
        timestamp read_at
        boolean is_system_message
    }

    PAYMENT {
        uuid id PK
        uuid patient_id FK
        uuid appointment_id FK
        string provider  "Stripe, PayPal, etc."
        string provider_payment_id
        string status  "PENDING/SUCCEEDED/FAILED/REFUNDED"
        numeric amount
        string currency
        timestamp created_at
        timestamp updated_at
    }

    NOTIFICATION {
        uuid id PK
        uuid user_id FK
        string type  "APPOINTMENT, CHAT, PAYMENT"
        string title
        string body
        boolean is_read
        timestamp created_at
    }

    USER ||--o| PATIENT_PROFILE : "has (role=PATIENT)"
    USER ||--o| DOCTOR_PROFILE : "has (role=DOCTOR)"

    DOCTOR_PROFILE ||--o{ DOCTOR_SPECIALTY : has
    SPECIALTY ||--o{ DOCTOR_SPECIALTY : has

    PATIENT_PROFILE ||--o{ FAVORITE_DOCTOR : marks
    DOCTOR_PROFILE ||--o{ FAVORITE_DOCTOR : "is favorite of"

    PATIENT_PROFILE ||--o{ REVIEW : writes
    DOCTOR_PROFILE ||--o{ REVIEW : "receives"

    PATIENT_PROFILE ||--o{ APPOINTMENT : books
    DOCTOR_PROFILE ||--o{ APPOINTMENT : "receives"

    DOCTOR_PROFILE ||--o{ DOCTOR_AVAILABILITY : "defines"

    PATIENT_PROFILE ||--o{ CHAT_THREAD : "participates"
    DOCTOR_PROFILE ||--o{ CHAT_THREAD : "participates"

    CHAT_THREAD ||--o{ CHAT_MESSAGE : contains
    USER ||--o{ CHAT_MESSAGE : "sends"

    PATIENT_PROFILE ||--o{ PAYMENT : makes
    APPOINTMENT ||--o| PAYMENT : "paid by"

    USER ||--o{ NOTIFICATION : "receives"
```

---

## 4. API Design Structure (High-Level)

Base path: `/api/v1`

### Auth (`/auth`)

* `POST /auth/register` – email/password registration.
* `POST /auth/login` – login, returns access & refresh tokens.
* `POST /auth/refresh` – refresh JWT.
* `POST /auth/logout` – revoke refresh token.
* `POST /auth/password/forgot` – send reset email/OTP.
* `POST /auth/password/reset` – reset password.
* `POST /auth/oauth/{provider}` – social login (Google, Facebook).

### Users & Profiles (`/users`, `/patients`, `/doctors`)

* `GET /users/me` – get current user.
* `PATCH /users/me` – update user settings (locale, theme).
* `GET /patients/me/profile` – get patient profile.
* `PATCH /patients/me/profile` – update patient profile.
* `GET /doctors` – list/browse doctors with filters.
* `GET /doctors/{doctor_id}` – doctor detail.
* `GET /doctors/{doctor_id}/reviews` – list reviews.
* `POST /doctors/{doctor_id}/reviews` – add review (patient only).
* `POST /doctors/{doctor_id}/favorite` – add to favorites.
* `DELETE /doctors/{doctor_id}/favorite` – remove from favorites.
* `GET /patients/me/favorites` – list favorite doctors.

### Appointments (`/appointments`)

* `GET /doctors/{doctor_id}/availability` – get available slots.
* `POST /appointments` – create appointment.
* `GET /appointments` – list my appointments (filters: upcoming, past).
* `GET /appointments/{appointment_id}` – appointment detail.
* `PATCH /appointments/{appointment_id}` – reschedule.
* `POST /appointments/{appointment_id}/cancel` – cancel.
* `GET /calendar/appointments` – calendar-friendly view (grouped by day).

### Chat (`/chat`)

* `GET /chat/threads` – list threads for current user.
* `POST /chat/threads` – create thread (if not existing).
* `GET /chat/threads/{thread_id}` – thread details + last messages.
* `GET /chat/threads/{thread_id}/messages` – paginated messages.
* **WebSocket:** `GET /ws/chat/{thread_id}` – real-time messaging.

### Payments (`/payments`)

* `POST /payments/intents` – create payment intent for an appointment.
* `GET /payments` – list my payments.
* `GET /payments/{payment_id}` – payment detail.
* `POST /payments/webhook/{provider}` – webhook endpoint (no auth, signed).

### Notifications (`/notifications`)

* `GET /notifications` – list notifications.
* `PATCH /notifications/{id}/read` – mark as read.
* `POST /notifications/test` – send test (dev only).

### Meta / Settings (`/meta`)

* `GET /meta/config` – app config (supported languages, theme options).
* `GET /meta/version` – API version, build info.

---

## 5. Authentication & Security Model

* **Auth type:** JWT-based (access + refresh) with OAuth2 password and social login.
* **Token lifetime:**

  * Access token: short (e.g., 15–30 minutes)
  * Refresh token: longer (e.g., 7–30 days), revocable
* **Social Login:** OAuth2/OpenID Connect (Google, Facebook).
* **Password Storage:** Argon2 or bcrypt with strong parameters.
* **Roles / RBAC:**

  * `PATIENT` – can browse doctors, book appointments, chat, pay.
  * `DOCTOR` – can manage availability, see appointments, chat with patients.
  * `ADMIN` – can manage users, doctors, specialties, see reports.
* **Transport Security:** HTTPS everywhere, HSTS on the gateway.
* **Data Protection:** sensitive fields (if any) encrypted at rest; logs avoid PII.
* **Input Validation:** Pydantic models for strict validation.
* **Rate Limiting:** at API gateway (e.g., Traefik/NGINX) especially for login endpoints.
* **Auditing:** log key events (login, password change, payment status changes, appointment updates).

---

## 6. Tech Stack Selection

**Language / Runtime**

* Python 3.12+

**Web Framework**

* FastAPI (ASGI, async support, automatic OpenAPI docs)

**Application Server**

* Uvicorn or Hypercorn behind NGINX/Traefik

**Data Layer**

* PostgreSQL (primary relational DB)
* SQLAlchemy 2.x or SQLModel
* Alembic for migrations

**Caching & Real-time**

* Redis:

  * Caching doctor availability, frequently used lists
  * Session-like data if needed
  * Pub/Sub for chat and notifications

**Async / Background Tasks**

* Celery or RQ with Redis as broker (for heavy tasks):

  * Send emails / push notifications
  * Payment webhook processing, retries
  * Periodic cleanups

**Real-time Chat**

* FastAPI WebSockets
* Redis Pub/Sub for scaling chat across instances (if multiple replicas)

**Auth**

* `python-jose` or `authlib` for JWT/OAuth2
* `passlib` for password hashing

**Testing**

* pytest + HTTPX or FastAPI TestClient

**DevOps**

* Docker + docker-compose for dev
* Kubernetes or managed container service for production

---

## 7. Sequence Diagrams (Mermaid)

### 7.1 Appointment Booking Flow

```mermaid
sequenceDiagram
    participant P as Patient (Mobile App)
    participant API as FastAPI Backend
    participant AS as AuthService
    participant DS as DoctorService
    participant APS as AppointmentService
    participant DB as PostgreSQL
    participant NS as NotificationService

    P->>API: POST /auth/login (email, password)
    API->>AS: validate credentials
    AS->>DB: query user
    DB-->>AS: user found
    AS-->>API: access + refresh tokens
    API-->>P: 200 OK (tokens)

    P->>API: GET /doctors?specialty=cardiology (with access token)
    API->>DS: fetch doctors list
    DS->>DB: SELECT doctors by specialty
    DB-->>DS: doctors list
    DS-->>API: doctors DTO
    API-->>P: doctors list

    P->>API: GET /doctors/{doctor_id}/availability
    API->>APS: get availability
    APS->>DB: query DOCTOR_AVAILABILITY + APPOINTMENTS
    DB-->>APS: slots + existing appointments
    APS-->>API: computed free slots
    API-->>P: available time slots

    P->>API: POST /appointments (doctor_id, slot, reason)
    API->>APS: create appointment request
    APS->>DB: check conflicts
    DB-->>APS: no conflict
    APS->>DB: INSERT APPOINTMENT(status=PENDING or CONFIRMED)
    DB-->>APS: appointment created
    APS->>NS: enqueue notification (patient+doctor)
    NS->>DB: INSERT NOTIFICATION rows
    APS-->>API: appointment DTO
    API-->>P: 201 Created (appointment details)
```

---

### 7.2 Chat Message Flow (Real-Time)

```mermaid
sequenceDiagram
    participant P as Patient App
    participant D as Doctor App
    participant WS as FastAPI WebSocket Endpoint
    participant CS as ChatService
    participant DB as PostgreSQL
    participant R as Redis Pub/Sub
    participant NS as NotificationService

    P->>WS: Connect /ws/chat/{thread_id} (JWT)
    WS->>CS: authenticate + join thread
    CS->>DB: verify thread and membership
    DB-->>CS: OK
    CS-->>WS: connection accepted

    D->>WS: Connect /ws/chat/{thread_id}
    WS->>CS: authenticate + join thread
    CS->>DB: verify thread and membership
    DB-->>CS: OK
    CS-->>WS: connection accepted

    P->>WS: send message("Hello Doctor")
    WS->>CS: handle incoming message
    CS->>DB: INSERT CHAT_MESSAGE
    DB-->>CS: saved
    CS->>R: publish message event (thread_id, message_id)

    R-->>WS: broadcast to all WS instances
    WS-->>D: deliver message in real-time

    alt Doctor offline
        CS->>NS: send push notification to doctor
        NS->>DB: INSERT NOTIFICATION
        NS-->>Doctor: push notification (via FCM/APNs)
    end
```

---

### 7.3 Payment Flow (Appointment Payment)

```mermaid
sequenceDiagram
    participant P as Patient App
    participant API as FastAPI Backend
    participant APS as AppointmentService
    participant PS as PaymentService
    participant GW as Payment Gateway
    participant WH as WebhookHandler
    participant DB as PostgreSQL
    participant NS as NotificationService

    P->>API: POST /payments/intents {appointment_id}
    API->>APS: validate appointment (status, ownership)
    APS->>DB: SELECT APPOINTMENT
    DB-->>APS: appointment (PENDING)
    APS-->>API: OK

    API->>PS: create payment intent
    PS->>GW: create payment intent (amount, currency, metadata)
    GW-->>PS: payment_intent_id + client_secret
    PS->>DB: INSERT PAYMENT(status=PENDING)
    DB-->>PS: saved
    PS-->>API: payment DTO + gateway client_secret
    API-->>P: return payment info for client SDK

    note over P,GW: Patient confirms payment in gateway UI/SDK

    GW-->>WH: POST /payments/webhook/stripe (event=payment_succeeded)
    WH->>PS: handle webhook event
    PS->>DB: UPDATE PAYMENT status=SUCCEEDED
    PS->>DB: UPDATE APPOINTMENT status=CONFIRMED
    PS->>NS: send payment + appointment notifications
    NS->>DB: INSERT NOTIFICATION rows
    NS-->>P: push/email receipt

    P->>API: GET /appointments/{id}
    API->>DB: SELECT APPOINTMENT
    DB-->>API: status=CONFIRMED
    API-->>P: appointment confirmed
```

---


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Below is a **professional, production-ready FastAPI folder structure** for your modular monolith + the **SQL database schema** generated from the ERD (PostgreSQL + Alembic-ready).

This structure is aligned with:

* Domain-Driven Design (DDD-lite)
* Modular Monolith
* Clean architecture principles
* FastAPI best practices
* Python 3.12 async standards

---

# 1. FastAPI Folder Structure (Modular Monolith)

This structure separates **domain modules**, **infrastructure**, **API layer**, and **application logic**.

```
app/
│
├── core/                           # Core framework & shared tools
│   ├── config.py                   # Settings (Pydantic BaseSettings)
│   ├── security.py                 # JWT, OAuth2, password hashing
│   ├── exceptions.py               # Custom exceptions & handlers
│   ├── dependencies.py             # Global dependencies
│   └── logging.py                  # Logging config
│
├── db/
│   ├── base.py                     # SQLAlchemy base (declarative base)
│   ├── session.py                  # DB session engine + async session
│   └── migrations/                 # Alembic migrations folder
│
├── models/                         # Global domain models (optional)
│   └── __init__.py
│
├── modules/                        # Bounded contexts (DDD modules)
│   │
│   ├── auth/
│   │   ├── routes.py               # FastAPI routes
│   │   ├── service.py              # Business logic
│   │   ├── schemas.py              # Pydantic models
│   │   ├── repository.py           # DB interactions
│   │   └── utils.py                # OAuth/social login helpers
│   │
│   ├── users/
│   │   ├── routes.py
│   │   ├── service.py
│   │   ├── schemas.py
│   │   ├── repository.py
│   │   ├── models.py               # SQLAlchemy models
│   │   └── utils.py
│   │
│   ├── doctors/
│   │   ├── routes.py
│   │   ├── service.py
│   │   ├── schemas.py
│   │   ├── repository.py
│   │   └── models.py
│   │
│   ├── appointments/
│   │   ├── routes.py
│   │   ├── service.py
│   │   ├── schemas.py
│   │   ├── repository.py
│   │   └── models.py
│   │
│   ├── chat/
│   │   ├── routes.py               # REST endpoints
│   │   ├── websocket.py            # WebSocket handler
│   │   ├── service.py
│   │   ├── schemas.py
│   │   ├── repository.py
│   │   └── models.py
│   │
│   ├── payments/
│   │   ├── routes.py
│   │   ├── service.py
│   │   ├── schemas.py
│   │   ├── repository.py
│   │   ├── webhook.py              # Stripe/PayPal webhook handlers
│   │   └── models.py
│   │
│   ├── notifications/
│   │   ├── routes.py
│   │   ├── service.py
│   │   ├── schemas.py
│   │   ├── repository.py
│   │   └── models.py
│   │
│   └── common/
│       ├── models.py               # Shared models
│       ├── utils.py
│       └── mixins.py               # Timestamp mixins, BaseModel mixins
│
├── utils/
│   ├── email.py                    # Email sending utils
│   ├── sms.py                      # SMS sending utils
│   ├── storage.py                  # File upload helpers
│   └── pagination.py
│
├── workers/                        # Celery tasks / background workers
│   ├── celery_app.py
│   └── tasks.py
│
├── main.py                         # FastAPI initialization
└── api_router.py                   # Include routers from all modules
```

### Why this structure is excellent:

* Clear module boundaries
* Highly maintainable
* Easy to scale to microservices later
* Supports domain separation
* Clean layers: `routes → service → repository`
* Follows established FastAPI best practices
* Ready for testing and CI/CD

---

# 2. PostgreSQL Database Schema (DDL)

This is a **production-ready SQL schema** matching your ERD exactly.
You can use it directly for Alembic migrations or initial schema setup.

---

## 2.1 `users` and roles

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL CHECK (role IN ('PATIENT', 'DOCTOR', 'ADMIN')),
    locale VARCHAR(10) DEFAULT 'en',
    theme_preference VARCHAR(10) DEFAULT 'light',
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

---

## 2.2 Patient Profile

```sql
CREATE TABLE patient_profile (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL UNIQUE REFERENCES users(id) ON DELETE CASCADE,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    date_of_birth DATE,
    phone VARCHAR(20),
    gender VARCHAR(20),
    address TEXT,
    city VARCHAR(100),
    country VARCHAR(100)
);
```

---

## 2.3 Doctor Profile

```sql
CREATE sql
CREATE TABLE doctor_profile (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL UNIQUE REFERENCES users(id) ON DELETE CASCADE,
    first_name VARCHAR(100),
    last_name VARCHAR(100),
    phone VARCHAR(20),
    bio TEXT,
    years_experience INT,
    clinic_address TEXT,
    city VARCHAR(100),
    country VARCHAR(100),
    avg_rating DECIMAL(3,2) DEFAULT 0,
    rating_count INT DEFAULT 0
);
```

---

## 2.4 Specialties & Doctor-Specialty mapping

```sql
CREATE TABLE specialty (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT
);

CREATE TABLE doctor_specialty (
    id UUID PRIMARY KEY,
    doctor_id UUID REFERENCES doctor_profile(id) ON DELETE CASCADE,
    specialty_id INT REFERENCES specialty(id) ON DELETE CASCADE
);
```

---

## 2.5 Favorite Doctors

```sql
CREATE TABLE favorite_doctor (
    id UUID PRIMARY KEY,
    patient_id UUID REFERENCES patient_profile(id),
    doctor_id UUID REFERENCES doctor_profile(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(patient_id, doctor_id)
);
```

---

## 2.6 Reviews

```sql
CREATE TABLE review (
    id UUID PRIMARY KEY,
    patient_id UUID REFERENCES patient_profile(id),
    doctor_id UUID REFERENCES doctor_profile(id),
    rating INT CHECK (rating BETWEEN 1 AND 5),
    comment TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

---

## 2.7 Appointments

```sql
CREATE TABLE appointment (
    id UUID PRIMARY KEY,
    patient_id UUID REFERENCES patient_profile(id),
    doctor_id UUID REFERENCES doctor_profile(id),
    start_time TIMESTAMP WITH TIME ZONE NOT NULL,
    end_time TIMESTAMP WITH TIME ZONE NOT NULL,
    status VARCHAR(20)
        NOT NULL
        CHECK (status IN ('PENDING', 'CONFIRMED', 'CANCELLED', 'COMPLETED')),
    reason TEXT,
    cancellation_reason TEXT,
    payment_id UUID,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

---

## 2.8 Doctor Availability

```sql
CREATE TABLE doctor_availability (
    id UUID PRIMARY KEY,
    doctor_id UUID REFERENCES doctor_profile(id) ON DELETE CASCADE,
    weekday VARCHAR(10) NOT NULL,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL,
    is_active BOOLEAN DEFAULT TRUE
);
```

---

## 2.9 Chat System

### Chat Thread

```sql
CREATE TABLE chat_thread (
    id UUID PRIMARY KEY,
    patient_id UUID REFERENCES patient_profile(id) ON DELETE CASCADE,
    doctor_id UUID REFERENCES doctor_profile(id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE(patient_id, doctor_id)
);
```

### Chat Messages

```sql
CREATE TABLE chat_message (
    id UUID PRIMARY KEY,
    thread_id UUID REFERENCES chat_thread(id) ON DELETE CASCADE,
    sender_id UUID REFERENCES users(id),
    sender_role VARCHAR(20) CHECK (sender_role IN ('PATIENT', 'DOCTOR')),
    content TEXT,
    sent_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    read_at TIMESTAMP WITH TIME ZONE,
    is_system_message BOOLEAN DEFAULT FALSE
);
```

---

## 2.10 Payments

```sql
CREATE TABLE payment (
    id UUID PRIMARY KEY,
    patient_id UUID REFERENCES patient_profile(id),
    appointment_id UUID REFERENCES appointment(id),
    provider VARCHAR(50),
    provider_payment_id VARCHAR(255),
    status VARCHAR(20)
        NOT NULL
        CHECK (status IN ('PENDING', 'SUCCEEDED', 'FAILED', 'REFUNDED')),
    amount DECIMAL(10,2) NOT NULL,
    currency VARCHAR(10) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

---

## 2.11 Notifications

```sql
CREATE TABLE notification (
    id UUID PRIMARY KEY,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    type VARCHAR(50),
    title VARCHAR(255),
    body TEXT,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

---


this is the project i am going to do
